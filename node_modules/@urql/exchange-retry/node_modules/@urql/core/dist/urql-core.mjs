import { visit as e, Kind as r, print as t } from "graphql";

import { k as n, s as o, C as s, m as u, a as c, b as p, c as v, d, e as l, g as y, f as k } from "./71ff986c.mjs";

export { C as CombinedError, f as createRequest, j as getOperationName, a as makeErrorResult, m as makeResult, i as mergeResultPatch, h as stringifyVariables } from "./71ff986c.mjs";

import { subscribe as g, share as x, map as w, filter as b, tap as E, merge as O, mergeMap as q, takeUntil as N, make as _, onPush as D, makeSubject as P, onEnd as S, onStart as R, publish as V, take as A, switchMap as M, fromValue as T } from "wonka";

var collectTypes = (e, r) => {
  if (Array.isArray(e)) {
    for (var t of e) {
      collectTypes(t, r);
    }
  } else if ("object" == typeof e && null !== e) {
    for (var a in e) {
      if ("__typename" === a && "string" == typeof e[a]) {
        r.add(e[a]);
      } else {
        collectTypes(e[a], r);
      }
    }
  }
  return r;
};

var formatNode = e => {
  if (!e.selectionSet) {
    return e;
  }
  for (var t of e.selectionSet.selections) {
    if (t.kind === r.FIELD && "__typename" === t.name.value && !t.alias) {
      return e;
    }
  }
  return {
    ...e,
    selectionSet: {
      ...e.selectionSet,
      selections: [ ...e.selectionSet.selections, {
        kind: r.FIELD,
        name: {
          kind: r.NAME,
          value: "__typename"
        }
      } ]
    }
  };
};

var I = new Map;

var formatDocument = r => {
  var t = n(r);
  var a = I.get(t.__key);
  if (!a) {
    a = e(t, {
      Field: formatNode,
      InlineFragment: formatNode
    });
    Object.defineProperty(a, "__key", {
      value: t.__key,
      enumerable: !1
    });
    I.set(t.__key, a);
  }
  return a;
};

var maskTypename = (e, r) => {
  if (!e || "object" != typeof e) {
    return e;
  } else if (Array.isArray(e)) {
    return e.map((e => maskTypename(e)));
  } else if (e && "object" == typeof e && (r || "__typename" in e)) {
    var t = {};
    for (var a in e) {
      if ("__typename" === a) {
        Object.defineProperty(t, "__typename", {
          enumerable: !1,
          value: e.__typename
        });
      } else {
        t[a] = maskTypename(e[a]);
      }
    }
    return t;
  } else {
    return e;
  }
};

function withPromise(e) {
  e.toPromise = () => new Promise((r => {
    var t = g((e => {
      if (!e.stale && !e.hasNext) {
        Promise.resolve().then((() => {
          t.unsubscribe();
          r(e);
        }));
      }
    }))(e);
  }));
  return e;
}

function makeOperation(e, r, t) {
  if (!t) {
    t = r.context;
  }
  return {
    key: r.key,
    query: r.query,
    variables: r.variables,
    kind: e,
    context: t
  };
}

var addMetadata = (e, r) => makeOperation(e.kind, e, {
  ...e.context,
  meta: {
    ...e.context.meta,
    ...r
  }
});

var noop = () => {};

var applyDefinitions = (e, t, a) => {
  for (var n of a) {
    if (n.kind === r.FRAGMENT_DEFINITION) {
      var i = n.name.value;
      var s = o(n);
      if (!e.has(i)) {
        e.set(i, s);
        t.push(n);
      } else if ("production" !== process.env.NODE_ENV && e.get(i) !== s) {
        console.warn("[WARNING: Duplicate Fragment] A fragment with name `" + i + "` already exists in this document.\nWhile fragment names may not be unique across your source, each name must be unique per document.");
      }
    } else {
      t.push(n);
    }
  }
};

function gql() {
  var e = new Map;
  var t = [];
  var a = [];
  var o = Array.isArray(arguments[0]) ? arguments[0][0] : arguments[0] || "";
  for (var i = 1; i < arguments.length; i++) {
    var s = arguments[i];
    if (s && s.definitions) {
      a.push(...s.definitions);
    } else {
      o += s;
    }
    o += arguments[0][i];
  }
  applyDefinitions(e, t, n(o).definitions);
  applyDefinitions(e, t, a);
  return n({
    kind: r.DOCUMENT,
    definitions: t
  });
}

var shouldSkip = ({kind: e}) => "mutation" !== e && "query" !== e;

var cacheExchange = ({forward: e, client: r, dispatchDebug: t}) => {
  var a = new Map;
  var n = new Map;
  var mapTypeNames = e => {
    var r = makeOperation(e.kind, e);
    r.query = formatDocument(e.query);
    return r;
  };
  var isOperationCached = e => {
    var {key: r, kind: t, context: {requestPolicy: n}} = e;
    return "query" === t && "network-only" !== n && ("cache-only" === n || a.has(r));
  };
  return o => {
    var i = x(o);
    var s = w((e => {
      var n = a.get(e.key);
      "production" !== process.env.NODE_ENV && t({
        operation: e,
        ...n ? {
          type: "cacheHit",
          message: "The result was successfully retried from the cache"
        } : {
          type: "cacheMiss",
          message: "The result could not be retrieved from the cache"
        },
        source: "cacheExchange"
      });
      var o = {
        ...n,
        operation: addMetadata(e, {
          cacheOutcome: n ? "hit" : "miss"
        })
      };
      if ("cache-and-network" === e.context.requestPolicy) {
        o.stale = !0;
        reexecuteOperation(r, e);
      }
      return o;
    }))(b((e => !shouldSkip(e) && isOperationCached(e)))(i));
    var u = E((e => {
      var {operation: o} = e;
      if (!o) {
        return;
      }
      var i = (e => [ ...collectTypes(e, new Set) ])(e.data).concat(o.context.additionalTypenames || []);
      if ("mutation" === e.operation.kind) {
        var s = new Set;
        "production" !== process.env.NODE_ENV && t({
          type: "cacheInvalidation",
          message: `The following typenames have been invalidated: ${i}`,
          operation: o,
          data: {
            typenames: i,
            response: e
          },
          source: "cacheExchange"
        });
        for (var u = 0; u < i.length; u++) {
          var c = i[u];
          var p = n.get(c);
          if (!p) {
            n.set(c, p = new Set);
          }
          for (var v of p.values()) {
            s.add(v);
          }
          p.clear();
        }
        for (var d of s.values()) {
          if (a.has(d)) {
            o = a.get(d).operation;
            a.delete(d);
            reexecuteOperation(r, o);
          }
        }
      } else if ("query" === o.kind && e.data) {
        a.set(o.key, e);
        for (var l = 0; l < i.length; l++) {
          var f = i[l];
          var h = n.get(f);
          if (!h) {
            n.set(f, h = new Set);
          }
          h.add(o.key);
        }
      }
    }))(e(b((e => "query" !== e.kind || "cache-only" !== e.context.requestPolicy))(w((e => addMetadata(e, {
      cacheOutcome: "miss"
    })))(O([ w(mapTypeNames)(b((e => !shouldSkip(e) && !isOperationCached(e)))(i)), b((e => shouldSkip(e)))(i) ])))));
    return O([ s, u ]);
  };
};

var reexecuteOperation = (e, r) => e.reexecuteOperation(makeOperation(r.kind, r, {
  ...r.context,
  requestPolicy: "network-only"
}));

var F = new Set;

var ssrExchange = (e = {}) => {
  var r = !!e.staleWhileRevalidate;
  var t = !!e.includeExtensions;
  var a = {};
  var n = [];
  var invalidate = e => {
    n.push(e.operation.key);
    if (1 === n.length) {
      Promise.resolve().then((() => {
        var e;
        while (e = n.shift()) {
          a[e] = null;
        }
      }));
    }
  };
  var ssr = ({client: n, forward: o}) => i => {
    var u = e && "boolean" == typeof e.isClient ? !!e.isClient : !n.suspense;
    var c = x(i);
    var p = o(b((e => !a[e.key] || !!a[e.key].hasNext))(c));
    var v = w((e => {
      var o = ((e, r, t) => ({
        operation: e,
        data: r.data ? JSON.parse(r.data) : void 0,
        extensions: t && r.extensions ? JSON.parse(r.extensions) : void 0,
        error: r.error ? new s({
          networkError: r.error.networkError ? new Error(r.error.networkError) : void 0,
          graphQLErrors: r.error.graphQLErrors
        }) : void 0,
        hasNext: r.hasNext
      }))(e, a[e.key], t);
      if (r && !F.has(e.key)) {
        o.stale = !0;
        F.add(e.key);
        reexecuteOperation(n, e);
      }
      return o;
    }))(b((e => !!a[e.key] && "network-only" !== e.context.requestPolicy))(c));
    if (!u) {
      p = E((e => {
        var {operation: r} = e;
        if ("mutation" !== r.kind) {
          var n = (({hasNext: e, data: r, extensions: t, error: a}, n) => {
            var o = {};
            if (void 0 !== r) {
              o.data = JSON.stringify(r);
            }
            if (n && void 0 !== t) {
              o.extensions = JSON.stringify(t);
            }
            if (e) {
              o.hasNext = !0;
            }
            if (a) {
              o.error = {
                graphQLErrors: a.graphQLErrors.map((e => {
                  if (!e.path && !e.extensions) {
                    return e.message;
                  }
                  return {
                    message: e.message,
                    path: e.path,
                    extensions: e.extensions
                  };
                }))
              };
              if (a.networkError) {
                o.error.networkError = "" + a.networkError;
              }
            }
            return o;
          })(e, t);
          a[r.key] = n;
        }
      }))(p);
    } else {
      v = E(invalidate)(v);
    }
    return O([ p, v ]);
  };
  ssr.restoreData = e => {
    for (var r in e) {
      if (null !== a[r]) {
        a[r] = e[r];
      }
    }
  };
  ssr.extractData = () => {
    var e = {};
    for (var r in a) {
      if (null != a[r]) {
        e[r] = a[r];
      }
    }
    return e;
  };
  if (e && e.initialState) {
    ssr.restoreData(e.initialState);
  }
  return ssr;
};

var subscriptionExchange = ({forwardSubscription: e, enableAllOperations: r, isSubscriptionOperation: a}) => ({client: n, forward: o}) => {
  var i = a || (e => {
    var {kind: t} = e;
    return "subscription" === t || !!r && ("query" === t || "mutation" === t);
  });
  return r => {
    var a = x(r);
    var s = q((r => {
      var {key: o} = r;
      var i = b((e => "teardown" === e.kind && e.key === o))(a);
      return N(i)((r => {
        var a = e({
          key: r.key.toString(36),
          query: t(r.query),
          variables: r.variables,
          context: {
            ...r.context
          }
        });
        return _((({next: e, complete: t}) => {
          var o = !1;
          var i;
          Promise.resolve().then((() => {
            if (o) {
              return;
            }
            i = a.subscribe({
              next: t => e(u(r, t)),
              error: t => e(c(r, t)),
              complete: () => {
                if (!o) {
                  o = !0;
                  if ("subscription" === r.kind) {
                    n.reexecuteOperation(makeOperation("teardown", r, r.context));
                  }
                  t();
                }
              }
            });
          }));
          return () => {
            o = !0;
            if (i) {
              i.unsubscribe();
            }
          };
        }));
      })(r));
    }))(b(i)(a));
    var p = o(b((e => !i(e)))(a));
    return O([ s, p ]);
  };
};

var debugExchange = ({forward: e}) => {
  if ("production" === process.env.NODE_ENV) {
    return r => e(r);
  } else {
    return r => E((e => console.log("[Exchange debug]: Completed operation: ", e)))(e(E((e => console.log("[Exchange debug]: Incoming operation: ", e)))(r)));
  }
};

var dedupExchange = ({forward: e, dispatchDebug: r}) => {
  var t = new Set;
  var filterIncomingOperation = e => {
    var {key: a, kind: n} = e;
    if ("teardown" === n || "mutation" === n) {
      t.delete(a);
      return !0;
    }
    var o = t.has(a);
    t.add(a);
    if (o) {
      "production" !== process.env.NODE_ENV && r({
        type: "dedup",
        message: "An operation has been deduped.",
        operation: e,
        source: "dedupExchange"
      });
    }
    return !o;
  };
  var afterOperationResult = ({operation: e, hasNext: r}) => {
    if (!r) {
      t.delete(e.key);
    }
  };
  return r => {
    var t = b(filterIncomingOperation)(r);
    return E(afterOperationResult)(e(t));
  };
};

var fetchExchange = ({forward: e, dispatchDebug: r}) => t => {
  var a = x(t);
  var n = q((e => {
    var {key: t} = e;
    var n = p(e);
    var o = v(e, n);
    var i = d(e, n);
    "production" !== process.env.NODE_ENV && r({
      type: "fetchRequest",
      message: "A fetch request is being executed.",
      operation: e,
      data: {
        url: o,
        fetchOptions: i
      },
      source: "fetchExchange"
    });
    var s = N(b((e => "teardown" === e.kind && e.key === t))(a))(l(e, o, i));
    if ("production" !== process.env.NODE_ENV) {
      return D((t => {
        var a = !t.data ? t.error : void 0;
        "production" !== process.env.NODE_ENV && r({
          type: a ? "fetchError" : "fetchSuccess",
          message: `A ${a ? "failed" : "successful"} fetch response has been returned.`,
          operation: e,
          data: {
            url: o,
            fetchOptions: i,
            value: a || t
          },
          source: "fetchExchange"
        });
      }))(s);
    }
    return s;
  }))(b((e => "query" === e.kind || "mutation" === e.kind))(a));
  var o = e(b((e => "query" !== e.kind && "mutation" !== e.kind))(a));
  return O([ n, o ]);
};

var fallbackExchange = ({dispatchDebug: e}) => r => b((() => !1))(E((r => {
  if ("teardown" !== r.kind && "production" !== process.env.NODE_ENV) {
    var t = `No exchange has handled operations of kind "${r.kind}". Check whether you've added an exchange responsible for these operations.`;
    "production" !== process.env.NODE_ENV && e({
      type: "fallbackCatch",
      message: t,
      operation: r,
      source: "fallbackExchange"
    });
    console.warn(t);
  }
}))(r));

var Q = fallbackExchange({
  dispatchDebug: noop
});

var composeExchanges = e => ({client: r, forward: t, dispatchDebug: a}) => e.reduceRight(((e, t) => t({
  client: r,
  forward: e,
  dispatchDebug(e) {
    "production" !== process.env.NODE_ENV && a({
      timestamp: Date.now(),
      source: t.name,
      ...e,
      source: "fetchExchange"
    });
  }
})), t);

var errorExchange = ({onError: e}) => ({forward: r}) => t => E((({error: r, operation: t}) => {
  if (r) {
    e(r, t);
  }
}))(r(t));

var L = [ dedupExchange, cacheExchange, fetchExchange ];

var $ = function Client(e) {
  if ("production" !== process.env.NODE_ENV && !e.url) {
    throw new Error("You are creating an urql-client without a url.");
  }
  var r = new Map;
  var t = new Map;
  var a = [];
  var n = {
    url: e.url,
    fetchOptions: e.fetchOptions,
    fetch: e.fetch,
    preferGetMethod: !!e.preferGetMethod,
    requestPolicy: e.requestPolicy || "cache-first"
  };
  var {source: o, next: i} = P();
  var s = !1;
  function dispatchOperation(e) {
    if (e) {
      i(e);
    }
    if (!s) {
      s = !0;
      while (s && (e = a.shift())) {
        i(e);
      }
      s = !1;
    }
  }
  var makeResultSource = n => {
    var s = b((e => e.operation.kind === n.kind && e.operation.key === n.key && (!e.operation.context._instance || e.operation.context._instance === n.context._instance)))(f);
    if (e.maskTypename) {
      s = w((e => ({
        ...e,
        data: maskTypename(e.data, !0)
      })))(s);
    }
    if ("mutation" === n.kind) {
      return A(1)(R((() => i(n)))(s));
    }
    return x(S((() => {
      r.delete(n.key);
      t.delete(n.key);
      for (var e = a.length - 1; e >= 0; e--) {
        if (a[e].key === n.key) {
          a.splice(e, 1);
        }
      }
      i(makeOperation("teardown", n, n.context));
    }))(D((e => {
      r.set(n.key, e);
    }))(M((e => {
      if ("query" !== n.kind || e.stale) {
        return T(e);
      }
      return O([ T(e), w((() => ({
        ...e,
        stale: !0
      })))(A(1)(b((e => "query" === e.kind && e.key === n.key && "cache-only" !== e.context.requestPolicy))(o))) ]);
    }))(N(b((e => "teardown" === e.kind && e.key === n.key))(o))(s)))));
  };
  var u = this instanceof Client ? this : Object.create(Client.prototype);
  var c = Object.assign(u, {
    suspense: !!e.suspense,
    operations$: o,
    reexecuteOperation(e) {
      if ("mutation" === e.kind || t.has(e.key)) {
        a.push(e);
        Promise.resolve().then(dispatchOperation);
      }
    },
    createRequestOperation(e, r, t) {
      if (!t) {
        t = {};
      }
      var a = y(r.query);
      if ("production" !== process.env.NODE_ENV && "teardown" !== e && a !== e) {
        throw new Error(`Expected operation of type "${e}" but found "${a}"`);
      }
      return makeOperation(e, r, {
        _instance: "mutation" === e ? [] : void 0,
        ...n,
        ...t,
        requestPolicy: t.requestPolicy || n.requestPolicy,
        suspense: t.suspense || !1 !== t.suspense && c.suspense
      });
    },
    executeRequestOperation(e) {
      if ("mutation" === e.kind) {
        return makeResultSource(e);
      }
      return _((a => {
        var n = t.get(e.key);
        if (!n) {
          t.set(e.key, n = makeResultSource(e));
        }
        var o = "cache-and-network" === e.context.requestPolicy || "network-only" === e.context.requestPolicy;
        return g(a.next)(S((() => {
          s = !1;
          a.complete();
        }))(R((() => {
          var t = r.get(e.key);
          if ("subscription" === e.kind) {
            return dispatchOperation(e);
          } else if (o) {
            dispatchOperation(e);
          }
          if (null != t && t === r.get(e.key)) {
            a.next(o ? {
              ...t,
              stale: !0
            } : t);
          } else if (!o) {
            dispatchOperation(e);
          }
        }))(n))).unsubscribe;
      }));
    },
    executeQuery(e, r) {
      var t = c.createRequestOperation("query", e, r);
      return c.executeRequestOperation(t);
    },
    executeSubscription(e, r) {
      var t = c.createRequestOperation("subscription", e, r);
      return c.executeRequestOperation(t);
    },
    executeMutation(e, r) {
      var t = c.createRequestOperation("mutation", e, r);
      return c.executeRequestOperation(t);
    },
    query(e, r, t) {
      if (!t || "boolean" != typeof t.suspense) {
        t = {
          ...t,
          suspense: !1
        };
      }
      return withPromise(c.executeQuery(k(e, r), t));
    },
    readQuery(e, r, t) {
      var a = null;
      g((e => {
        a = e;
      }))(c.query(e, r, t)).unsubscribe();
      return a;
    },
    subscription: (e, r, t) => c.executeSubscription(k(e, r), t),
    mutation: (e, r, t) => withPromise(c.executeMutation(k(e, r), t))
  });
  var p = noop;
  if ("production" !== process.env.NODE_ENV) {
    var {next: v, source: d} = P();
    c.subscribeToDebugTarget = e => g(e)(d);
    p = v;
  }
  var l = composeExchanges(void 0 !== e.exchanges ? e.exchanges : L);
  var f = x(l({
    client: c,
    dispatchDebug: p,
    forward: fallbackExchange({
      dispatchDebug: p
    })
  })(o));
  V(f);
  return c;
};

var G = $;

export { $ as Client, cacheExchange, composeExchanges, G as createClient, debugExchange, dedupExchange, L as defaultExchanges, errorExchange, Q as fallbackExchangeIO, fetchExchange, formatDocument, gql, makeOperation, maskTypename, ssrExchange, subscriptionExchange };
//# sourceMappingURL=urql-core.mjs.map
